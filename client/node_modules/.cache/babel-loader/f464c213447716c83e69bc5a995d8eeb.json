{"ast":null,"code":"import _toConsumableArray from \"/Users/daniel/Development/world-factbook/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport clip from \"./index\";\nimport { atan2, cos, max, min, pi, radians, sign, sin, sqrt } from \"../math\";\nimport { cartesian, cartesianCross, cartesianDot, cartesianEqual, spherical } from \"../cartesian\";\nimport { intersectCoincident, intersectPointOnLine, intersectSegment, intersect } from \"../intersect\";\nimport { default as polygonContains } from \"../polygonContains\";\n\nvar clipNone = function clipNone(stream) {\n  return stream;\n}; // clipPolygon\n\n\nexport default function (geometry) {\n  function clipGeometry(geometry) {\n    var polygons;\n\n    if (geometry.type === \"MultiPolygon\") {\n      polygons = geometry.coordinates;\n    } else if (geometry.type === \"Polygon\") {\n      polygons = [geometry.coordinates];\n    } else {\n      return clipNone;\n    }\n\n    var clips = polygons.map(function (polygon) {\n      polygon = polygon.map(ringRadians);\n      var pointVisible = visible(polygon),\n          segments = ringSegments(polygon[0]); // todo holes?\n\n      return clip(pointVisible, clipLine(segments, pointVisible), interpolate(segments, polygon), polygon[0][0], clipPolygonSort);\n    });\n\n    var clipPolygon = function clipPolygon(stream) {\n      var clipstream = clips.map(function (clip) {\n        return clip(stream);\n      });\n      return {\n        point: function point(lambda, phi) {\n          clipstream.forEach(function (clip) {\n            return clip.point(lambda, phi);\n          });\n        },\n        lineStart: function lineStart() {\n          clipstream.forEach(function (clip) {\n            return clip.lineStart();\n          });\n        },\n        lineEnd: function lineEnd() {\n          clipstream.forEach(function (clip) {\n            return clip.lineEnd();\n          });\n        },\n        polygonStart: function polygonStart() {\n          clipstream.forEach(function (clip) {\n            return clip.polygonStart();\n          });\n        },\n        polygonEnd: function polygonEnd() {\n          clipstream.forEach(function (clip) {\n            return clip.polygonEnd();\n          });\n        },\n        sphere: function sphere() {\n          clipstream.forEach(function (clip) {\n            return clip.sphere();\n          });\n        }\n      };\n    };\n\n    clipPolygon.polygon = function (_) {\n      return _ ? (geometry = _, clipGeometry(geometry)) : geometry;\n    };\n\n    return clipPolygon;\n  }\n\n  return clipGeometry(geometry);\n}\n\nfunction ringRadians(ring) {\n  return ring.map(function (point) {\n    return [point[0] * radians, point[1] * radians];\n  });\n}\n\nfunction ringSegments(ring) {\n  var c,\n      c0,\n      segments = [];\n  ring.forEach(function (point, i) {\n    c = cartesian(point);\n    if (i) segments.push(new intersectSegment(c0, c));\n    c0 = c;\n    return point;\n  });\n  return segments;\n}\n\nfunction clipPolygonSort(a, b) {\n  a = a.x, b = b.x;\n  return a.index - b.index || a.t - b.t;\n}\n\nfunction interpolate(segments, polygon) {\n  return function (from, to, direction, stream) {\n    if (from == null) {\n      stream.polygonStart();\n      polygon.forEach(function (ring) {\n        stream.lineStart();\n        ring.forEach(function (point) {\n          stream.point(point[0], point[1]);\n        });\n        stream.lineEnd();\n      });\n      stream.polygonEnd();\n    } else if (from.index !== to.index && from.index != null && to.index != null) {\n      for (var i = from.index; i !== to.index; i = (i + direction + segments.length) % segments.length) {\n        var segment = segments[i],\n            point = spherical(direction > 0 ? segment.to : segment.from);\n        stream.point(point[0], point[1]);\n      }\n    } else if (from.index === to.index && from.t > to.t && from.index != null && to.index != null) {\n      for (i = 0; i < segments.length; i++) {\n        segment = segments[(from.index + i * direction + segments.length) % segments.length], point = spherical(direction > 0 ? segment.to : segment.from);\n        stream.point(point[0], point[1]);\n      }\n    }\n  };\n} // Geodesic coordinates for two 3D points.\n\n\nfunction clipPolygonDistance(a, b) {\n  var axb = cartesianCross(a, b);\n  return atan2(sqrt(cartesianDot(axb, axb)), cartesianDot(a, b));\n}\n\nfunction visible(polygon) {\n  return function (lambda, phi) {\n    return polygonContains(polygon, [lambda, phi]);\n  };\n}\n\nfunction randsign(i, j) {\n  return sign(sin(100 * i + j));\n}\n\nfunction clipLine(segments, pointVisible) {\n  return function (stream) {\n    var point0,\n        lambda00,\n        phi00,\n        v00,\n        v0,\n        _clean,\n        line,\n        lines = [];\n\n    return {\n      lineStart: function lineStart() {\n        point0 = null;\n        _clean = 1;\n        line = [];\n      },\n      lineEnd: function lineEnd() {\n        if (v0) lines.push(line);\n        lines.forEach(function (line) {\n          stream.lineStart();\n          line.forEach(function (point) {\n            stream.point.apply(stream, _toConsumableArray(point)); // can have 4 dimensions\n          });\n          stream.lineEnd();\n        });\n        lines = [];\n      },\n      point: function point(lambda, phi, close) {\n        if (cos(lambda) == -1) lambda -= sign(sin(lambda)) * 1e-5; // move away from -180/180 https://github.com/d3/d3-geo/pull/108#issuecomment-323798937\n\n        if (close) lambda = lambda00, phi = phi00;\n        var point = cartesian([lambda, phi]),\n            v = v0,\n            intersection,\n            i,\n            j,\n            s,\n            t;\n\n        if (point0) {\n          var segment = new intersectSegment(point0, point),\n              intersections = [];\n\n          for (i = 0, j = 100; i < segments.length && j > 0; ++i) {\n            s = segments[i];\n            intersection = intersect(segment, s);\n\n            if (intersection) {\n              if (intersection === intersectCoincident || cartesianEqual(intersection, point0) || cartesianEqual(intersection, point) || cartesianEqual(intersection, s.from) || cartesianEqual(intersection, s.to)) {\n                t = 1e-4;\n                lambda = (lambda + 3 * pi + randsign(i, j) * t) % (2 * pi) - pi;\n                phi = min(pi / 2 - 1e-4, max(1e-4 - pi / 2, phi + randsign(i, j) * t));\n                segment = new intersectSegment(point0, point = cartesian([lambda, phi]));\n                i = -1, --j;\n                intersections.length = 0;\n                continue;\n              }\n\n              var sph = spherical(intersection);\n              intersection.distance = clipPolygonDistance(point0, intersection);\n              intersection.index = i;\n              intersection.t = clipPolygonDistance(s.from, intersection);\n              intersection[0] = sph[0], intersection[1] = sph[1], intersection.pop();\n              intersections.push(intersection);\n            }\n          }\n\n          if (intersections.length) {\n            _clean = 0;\n            intersections.sort(function (a, b) {\n              return a.distance - b.distance;\n            });\n\n            for (i = 0; i < intersections.length; ++i) {\n              intersection = intersections[i];\n              v = !v;\n\n              if (v) {\n                line = [];\n                line.push([intersection[0], intersection[1], intersection.index, intersection.t]);\n              } else {\n                line.push([intersection[0], intersection[1], intersection.index, intersection.t]);\n                lines.push(line);\n              }\n            }\n          }\n\n          if (v) line.push([lambda, phi]);\n        } else {\n          for (i = 0, j = 100; i < segments.length && j > 0; ++i) {\n            s = segments[i];\n\n            if (intersectPointOnLine(point, s)) {\n              t = 1e-4;\n              lambda = (lambda + 3 * pi + randsign(i, j) * t) % (2 * pi) - pi;\n              phi = min(pi / 2 - 1e-4, max(1e-4 - pi / 2, phi + randsign(i, j) * t));\n              point = cartesian([lambda, phi]);\n              i = -1, --j;\n            }\n          }\n\n          v00 = v = pointVisible(lambda00 = lambda, phi00 = phi);\n          if (v) line = [], line.push([lambda, phi]);\n        }\n\n        point0 = point, v0 = v;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function clean() {\n        return _clean | (v00 && v0) << 1;\n      }\n    };\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
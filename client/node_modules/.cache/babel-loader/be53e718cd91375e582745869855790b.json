{"ast":null,"code":"/*\n * Buckminster Fuller’s AirOcean arrangement of the icosahedron\n *\n * Implemented for D3.js by Jason Davies (2013),\n * Enrico Spinielli (2017) and Philippe Rivière (2017, 2018)\n *\n */\nimport { atan, degrees } from \"./math\";\nimport polyhedral from \"./polyhedral/index\";\nimport { default as grayFullerRaw } from \"./grayfuller\";\nimport { geoCentroid as centroid, geoContains as _contains, geoGnomonic as gnomonic, geoProjection as projection } from \"d3-geo\";\nimport { range } from \"d3-array\";\n\nfunction airoceanRaw(faceProjection) {\n  var theta = atan(0.5) * degrees; // construction inspired by\n  // https://en.wikipedia.org/wiki/Regular_icosahedron#Spherical_coordinates\n\n  var vertices = [[0, 90], [0, -90]].concat(range(10).map(function (i) {\n    var phi = (i * 36 + 180) % 360 - 180;\n    return [phi, i & 1 ? theta : -theta];\n  })); // icosahedron\n\n  var polyhedron = [[0, 3, 11], [0, 5, 3], [0, 7, 5], [0, 9, 7], [0, 11, 9], // North\n  [2, 11, 3], [3, 4, 2], [4, 3, 5], [5, 6, 4], [6, 5, 7], [7, 8, 6], [8, 7, 9], [9, 10, 8], [10, 9, 11], [11, 2, 10], // Equator\n  [1, 2, 4], [1, 4, 6], [1, 6, 8], [1, 8, 10], [1, 10, 2] // South\n  ].map(function (face) {\n    return face.map(function (i) {\n      return vertices[i];\n    });\n  }); // add centroid\n\n  polyhedron.forEach(function (face) {\n    face.centroid = centroid({\n      type: \"MultiPoint\",\n      coordinates: face\n    });\n  }); // split the relevant faces:\n  // * face[15] in the centroid: this will become face[15], face[20] and face[21]\n  // * face[14] in the middle of the side: this will become face[14] and face[22]\n\n  (function () {\n    var face, tmp, mid, centroid; // Split face[15] in 3 faces at centroid.\n\n    face = polyhedron[15];\n    centroid = face.centroid;\n    tmp = face.slice();\n    face[0] = centroid; // (new) face[15]\n\n    face = [tmp[0], centroid, tmp[2]];\n    face.centroid = centroid;\n    polyhedron.push(face); // face[20]\n\n    face = [tmp[0], tmp[1], centroid];\n    face.centroid = centroid;\n    polyhedron.push(face); // face[21]\n    // Split face 14 at the edge.\n\n    face = polyhedron[14];\n    centroid = face.centroid;\n    tmp = face.slice(); // compute planar midpoint\n\n    var proj = gnomonic().scale(1).translate([0, 0]).rotate([-centroid[0], -centroid[1]]);\n    var a = proj(face[1]),\n        b = proj(face[2]);\n    mid = proj.invert([(a[0] + b[0]) / 2, (a[1] + b[1]) / 2]);\n    face[1] = mid; // (new) face[14]\n    // build the new half face\n\n    face = [tmp[0], tmp[1], mid];\n    face.centroid = centroid; // use original face[14] centroid\n\n    polyhedron.push(face); // face[22]\n    // cut face 19 to connect to 22\n\n    face = polyhedron[19];\n    centroid = face.centroid;\n    tmp = face.slice();\n    face[1] = mid; // build the new half face\n\n    face = [mid, tmp[0], tmp[1]];\n    face.centroid = centroid;\n    polyhedron.push(face); // face[23]\n  })();\n\n  var airocean = function airocean(faceProjection) {\n    faceProjection = faceProjection || function (face) {\n      // for half-triangles this is definitely not centroid({type: \"MultiPoint\", coordinates: face});\n      var c = face.centroid;\n      return gnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n    };\n\n    var faces = polyhedron.map(function (face, i) {\n      var polygon = face.slice();\n      polygon.push(polygon[0]);\n      return {\n        face: face,\n        site: face.centroid,\n        id: i,\n        contains: function contains(lambda, phi) {\n          return _contains({\n            type: \"Polygon\",\n            coordinates: [polygon]\n          }, [lambda * degrees, phi * degrees]);\n        },\n        project: faceProjection(face)\n      };\n    }); // Connect each face to a parent face.\n\n    var parents = [// N\n    -1, // 0\n    0, // 1\n    1, // 2\n    11, // 3\n    13, // 4\n    // Eq\n    6, // 5\n    7, // 6\n    1, // 7\n    7, // 8\n    8, // 9\n    9, // 10\n    10, // 11\n    11, // 12\n    12, // 13\n    13, // 14\n    // S\n    6, // 15\n    8, // 16\n    10, // 17\n    17, // 18\n    21, // 19\n    16, // 20\n    15, // 21\n    19, // 22\n    19 // 23\n    ];\n    parents.forEach(function (d, i) {\n      var node = faces[d];\n      node && (node.children || (node.children = [])).push(faces[i]);\n    });\n\n    function face(lambda, phi) {\n      for (var i = 0; i < faces.length; i++) {\n        if (faces[i].contains(lambda, phi)) return faces[i];\n      }\n    } // Polyhedral projection\n\n\n    var proj = polyhedral(faces[0], // the root face\n    face // a function that returns a face given coords\n    );\n    proj.faces = faces;\n    return proj;\n  };\n\n  return airocean(faceProjection);\n}\n\nexport default function () {\n  var p = airoceanRaw(function (face) {\n    var c = face.centroid;\n    face.direction = Math.abs(c[1] - 52.62) < 1 || Math.abs(c[1] + 10.81) < 1 ? 0 : 60;\n    return projection(grayFullerRaw()).scale(1).translate([0, 0]).rotate([-c[0], -c[1], face.direction || 0]);\n  });\n  return p.rotate([-83.65929, 25.44458, -87.45184]).angle(-60).scale(45.4631).center([126, 0]);\n}","map":null,"metadata":{},"sourceType":"module"}
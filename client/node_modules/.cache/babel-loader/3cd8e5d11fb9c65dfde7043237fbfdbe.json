{"ast":null,"code":"import { geoProjection as projection, geoStereographicRaw, geoCentroid, geoContains } from \"d3-geo\";\nimport polyhedral from \"./polyhedral/index\";\nimport { scan } from \"d3-array\";\nimport { abs, asin, degrees, sqrt } from \"./math\";\nimport { complexAdd, complexMul, complexNorm, complexPow, complexSub } from \"./complex\";\nexport function leeRaw(lambda, phi) {\n  // return d3.geoGnomonicRaw(...arguments);\n  var w = [-1 / 2, sqrt(3) / 2],\n      k = [0, 0],\n      h = [0, 0],\n      i,\n      z = complexMul(geoStereographicRaw(lambda, phi), [sqrt(2), 0]); // rotate to have s ~= 1\n\n  var sector = scan([0, 1, 2].map(function (i) {\n    return -complexMul(z, complexPow(w, [i, 0]))[0];\n  }));\n  var rot = complexPow(w, [sector, 0]);\n  var n = complexNorm(z);\n\n  if (n > 0.3) {\n    // if |z| > 0.5, use the approx based on y = (1-z)\n    // McIlroy formula 6 p6 and table for G page 16\n    var y = complexSub([1, 0], complexMul(rot, z)); // w1 = gamma(1/3) * gamma(1/2) / 3 / gamma(5/6);\n    // https://bl.ocks.org/Fil/1aeff1cfda7188e9fbf037d8e466c95c\n\n    var w1 = 1.4021821053254548;\n    var G0 = [1.15470053837925, 0.192450089729875, 0.0481125224324687, 0.010309826235529, 3.34114739114366e-4, -1.50351632601465e-3, -1.2304417796231e-3, -6.75190201960282e-4, -2.84084537293856e-4, -8.21205120500051e-5, -1.59257630018706e-6, 1.91691805888369e-5, 1.73095888028726e-5, 1.03865580818367e-5, 4.70614523937179e-6, 1.4413500104181e-6, 1.92757960170179e-8, -3.82869799649063e-7, -3.57526015225576e-7, -2.2175964844211e-7];\n    var G = [0, 0];\n\n    for (i = G0.length; i--;) {\n      G = complexAdd([G0[i], 0], complexMul(G, y));\n    }\n\n    k = complexSub([w1, 0], complexMul(complexPow(y, 1 / 2), G));\n    k = complexMul(k, rot);\n    k = complexMul(k, rot);\n  }\n\n  if (n < 0.5) {\n    // if |z| < 0.3\n    // https://www.wolframalpha.com/input/?i=series+of+((1-z%5E3))+%5E+(-1%2F2)+at+z%3D0 (and ask for \"more terms\")\n    // 1 + z^3/2 + (3 z^6)/8 + (5 z^9)/16 + (35 z^12)/128 + (63 z^15)/256 + (231 z^18)/1024 + O(z^21)\n    // https://www.wolframalpha.com/input/?i=integral+of+1+%2B+z%5E3%2F2+%2B+(3+z%5E6)%2F8+%2B+(5+z%5E9)%2F16+%2B+(35+z%5E12)%2F128+%2B+(63+z%5E15)%2F256+%2B+(231+z%5E18)%2F1024\n    // (231 z^19)/19456 + (63 z^16)/4096 + (35 z^13)/1664 + z^10/32 + (3 z^7)/56 + z^4/8 + z + constant\n    var H0 = [1, 1 / 8, 3 / 56, 1 / 32, 35 / 1664, 63 / 4096, 231 / 19456];\n    var z3 = complexPow(z, [3, 0]);\n\n    for (i = H0.length; i--;) {\n      h = complexAdd([H0[i], 0], complexMul(h, z3));\n    }\n\n    h = complexMul(h, z);\n  }\n\n  if (n < 0.3) return h;\n  if (n > 0.5) return k; // in between 0.3 and 0.5, interpolate\n\n  var t = (n - 0.3) / (0.5 - 0.3);\n  return complexAdd(complexMul(k, [t, 0]), complexMul(h, [1 - t, 0]));\n}\nvar asin1_3 = asin(1 / 3);\nvar centers = [[0, 90], [-180, -asin1_3 * degrees], [-60, -asin1_3 * degrees], [60, -asin1_3 * degrees]];\nvar tetrahedron = [[1, 2, 3], [0, 2, 1], [0, 3, 2], [0, 1, 3]].map(function (face) {\n  return face.map(function (i) {\n    return centers[i];\n  });\n});\nexport default function () {\n  var faceProjection = function faceProjection(face) {\n    var c = geoCentroid({\n      type: \"MultiPoint\",\n      coordinates: face\n    }),\n        rotate = [-c[0], -c[1], 30];\n\n    if (abs(c[1]) == 90) {\n      rotate = [0, -c[1], -30];\n    }\n\n    return projection(leeRaw).scale(1).translate([0, 0]).rotate(rotate);\n  };\n\n  var faces = tetrahedron.map(function (face) {\n    return {\n      face: face,\n      project: faceProjection(face)\n    };\n  });\n  [-1, 0, 0, 0].forEach(function (d, i) {\n    var node = faces[d];\n    node && (node.children || (node.children = [])).push(faces[i]);\n  });\n  var p = polyhedral(faces[0], function (lambda, phi) {\n    lambda *= degrees;\n    phi *= degrees;\n\n    for (var i = 0; i < faces.length; i++) {\n      if (geoContains({\n        type: \"Polygon\",\n        coordinates: [[tetrahedron[i][0], tetrahedron[i][1], tetrahedron[i][2], tetrahedron[i][0]]]\n      }, [lambda, phi])) {\n        return faces[i];\n      }\n    }\n  });\n  return p.rotate([30, 180]) // North Pole aspect, needs clipPolygon\n  // .rotate([-30, 0]) // South Pole aspect\n  .angle(30).scale(118.662).translate([480, 195.47]);\n}","map":null,"metadata":{},"sourceType":"module"}
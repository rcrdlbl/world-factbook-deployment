{"ast":null,"code":"/*\n * Cahill-Keyes projection\n *\n * Implemented in Perl by Mary Jo Graça (2011)\n *\n * Ported to D3.js by Enrico Spinielli (2013)\n *\n */\nimport { abs, cos, degrees, pi, radians, sin, sign, sqrt, tan } from \"./math\";\nimport { cartesianCross, cartesianDegrees, cartesianDot, sphericalDegrees } from \"./cartesian\";\nimport polyhedral from \"./polyhedral/index\";\nimport { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nexport default function (faceProjection) {\n  faceProjection = faceProjection || function () {\n    return cahillKeyesProjection().scale(1);\n  };\n\n  var octahedron = [[0, 90], [-90, 0], [0, 0], [90, 0], [180, 0], [0, -90]];\n  octahedron = [[0, 2, 1], [0, 3, 2], [5, 1, 2], [5, 2, 3], [0, 1, 4], [0, 4, 3], [5, 4, 1], [5, 3, 4]].map(function (face) {\n    return face.map(function (i) {\n      return octahedron[i];\n    });\n  });\n  var ck = octahedron.map(function (face) {\n    var xyz = face.map(cartesianDegrees),\n        n = xyz.length,\n        a = xyz[n - 1],\n        b,\n        theta = 17 * radians,\n        cosTheta = cos(theta),\n        sinTheta = sin(theta),\n        hexagon = [];\n\n    for (var i = 0; i < n; ++i) {\n      b = xyz[i];\n      hexagon.push(sphericalDegrees([a[0] * cosTheta + b[0] * sinTheta, a[1] * cosTheta + b[1] * sinTheta, a[2] * cosTheta + b[2] * sinTheta]), sphericalDegrees([b[0] * cosTheta + a[0] * sinTheta, b[1] * cosTheta + a[1] * sinTheta, b[2] * cosTheta + a[2] * sinTheta]));\n      a = b;\n    }\n\n    return hexagon;\n  });\n  var cornerNormals = [];\n  var parents = [-1, 3, 0, 2, 0, 1, 4, 5];\n  ck.forEach(function (hexagon, j) {\n    var face = octahedron[j],\n        n = face.length,\n        normals = cornerNormals[j] = [];\n\n    for (var i = 0; i < n; ++i) {\n      ck.push([face[i], hexagon[(i * 2 + 2) % (2 * n)], hexagon[(i * 2 + 1) % (2 * n)]]);\n      parents.push(j);\n      normals.push(cartesianCross(cartesianDegrees(hexagon[(i * 2 + 2) % (2 * n)]), cartesianDegrees(hexagon[(i * 2 + 1) % (2 * n)])));\n    }\n  });\n  var faces = ck.map(function (face) {\n    return {\n      project: faceProjection(face),\n      face: face\n    };\n  });\n  parents.forEach(function (d, i) {\n    var parent = faces[d];\n    parent && (parent.children || (parent.children = [])).push(faces[i]);\n  });\n  return polyhedral(faces[0], face, 0, true).scale(0.023975).rotate([20, 0]).center([0, -17]);\n\n  function face(lambda, phi) {\n    var cosPhi = cos(phi),\n        p = [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n    var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;\n    var n = cornerNormals[hexagon];\n    return faces[cartesianDot(n[0], p) < 0 ? 8 + 3 * hexagon : cartesianDot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : cartesianDot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];\n  }\n} // all names of reference points, A, B, D, ... , G, P75\n// or zones, A-L, are detailed fully in Gene Keyes'\n// web site http://www.genekeyes.com/CKOG-OOo/7-CKOG-illus-&-coastline.html\n\nexport function cahillKeyesRaw(mg) {\n  var CK = {\n    lengthMG: mg // magic scaling length\n\n  };\n  preliminaries();\n\n  function preliminaries() {\n    var pointN, lengthMB, lengthMN, lengthNG, pointU;\n    var m = 29,\n        // meridian\n    p = 15,\n        // parallel\n    p73a,\n        lF,\n        lT,\n        lM,\n        l,\n        pointV,\n        k = sqrt(3);\n    CK.lengthMA = 940 / 10000 * CK.lengthMG;\n    CK.lengthParallel0to73At0 = CK.lengthMG / 100;\n    CK.lengthParallel73to90At0 = (CK.lengthMG - CK.lengthMA - CK.lengthParallel0to73At0 * 73) / (90 - 73);\n    CK.sin60 = k / 2; // √3/2 \n\n    CK.cos60 = 0.5;\n    CK.pointM = [0, 0];\n    CK.pointG = [CK.lengthMG, 0];\n    pointN = [CK.lengthMG, CK.lengthMG * tan(30 * radians)];\n    CK.pointA = [CK.lengthMA, 0];\n    CK.pointB = lineIntersection(CK.pointM, 30, CK.pointA, 45);\n    CK.lengthAG = distance(CK.pointA, CK.pointG);\n    CK.lengthAB = distance(CK.pointA, CK.pointB);\n    lengthMB = distance(CK.pointM, CK.pointB);\n    lengthMN = distance(CK.pointM, pointN);\n    lengthNG = distance(pointN, CK.pointG);\n    CK.pointD = interpolate(lengthMB, lengthMN, pointN, CK.pointM);\n    CK.pointF = [CK.lengthMG, lengthNG - lengthMB];\n    CK.pointE = [pointN[0] - CK.lengthMA * sin(30 * radians), pointN[1] - CK.lengthMA * cos(30 * radians)];\n    CK.lengthGF = distance(CK.pointG, CK.pointF);\n    CK.lengthBD = distance(CK.pointB, CK.pointD);\n    CK.lengthBDE = CK.lengthBD + CK.lengthAB; // lengthAB = lengthDE \n\n    CK.lengthGFE = CK.lengthGF + CK.lengthAB; // lengthAB = lengthFE \n\n    CK.deltaMEq = CK.lengthGFE / 45;\n    CK.lengthAP75 = (90 - 75) * CK.lengthParallel73to90At0;\n    CK.lengthAP73 = CK.lengthMG - CK.lengthMA - CK.lengthParallel0to73At0 * 73;\n    pointU = [CK.pointA[0] + CK.lengthAP73 * cos(30 * radians), CK.pointA[1] + CK.lengthAP73 * sin(30 * radians)];\n    CK.pointT = lineIntersection(pointU, -60, CK.pointB, 30);\n    p73a = parallel73(m);\n    lF = p73a.lengthParallel73;\n    lT = lengthTorridSegment(m);\n    lM = lengthMiddleSegment(m);\n    l = p * (lT + lM + lF) / 73;\n    pointV = [0, 0];\n    CK.pointC = [0, 0];\n    CK.radius = 0;\n    l = l - lT;\n    pointV = interpolate(l, lM, jointT(m), jointF(m));\n    CK.pointC[1] = (pointV[0] * pointV[0] + pointV[1] * pointV[1] - CK.pointD[0] * CK.pointD[0] - CK.pointD[1] * CK.pointD[1]) / (2 * (k * pointV[0] + pointV[1] - k * CK.pointD[0] - CK.pointD[1]));\n    CK.pointC[0] = k * CK.pointC[1];\n    CK.radius = distance(CK.pointC, CK.pointD);\n    return CK;\n  } //**** helper functions ****//\n  // distance between two 2D coordinates\n\n\n  function distance(p1, p2) {\n    var deltaX = p1[0] - p2[0],\n        deltaY = p1[1] - p2[1];\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n  } // return 2D point at position length/totallength of the line\n  // defined by two 2D points, start and end.\n\n\n  function interpolate(length, totalLength, start, end) {\n    var xy = [start[0] + (end[0] - start[0]) * length / totalLength, start[1] + (end[1] - start[1]) * length / totalLength];\n    return xy;\n  } // return the 2D point intersection between two lines defined\n  // by one 2D point and a slope each.\n\n\n  function lineIntersection(point1, slope1, point2, slope2) {\n    // s1/s2 = slope in degrees\n    var m1 = tan(slope1 * radians),\n        m2 = tan(slope2 * radians),\n        p = [0, 0];\n    p[0] = (m1 * point1[0] - m2 * point2[0] - point1[1] + point2[1]) / (m1 - m2);\n    p[1] = m1 * (p[0] - point1[0]) + point1[1];\n    return p;\n  } // return the 2D point intercepting a circumference centered\n  // at cc and of radius rn and a line defined by 2 points, p1 and p2:\n  // First element of the returned array is a flag to state whether there is\n  // an intersection, a value of zero (0) means NO INTERSECTION.\n  // The following array is the 2D point of the intersection.\n  // Equations from \"Intersection of a Line and a Sphere (or circle)/Line Segment\"\n  // at http://paulbourke.net/geometry/circlesphere/\n\n\n  function circleLineIntersection(cc, r, p1, p2) {\n    var x1 = p1[0],\n        y1 = p1[1],\n        x2 = p2[0],\n        y2 = p2[1],\n        xc = cc[0],\n        yc = cc[1],\n        a = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1),\n        b = 2 * ((x2 - x1) * (x1 - xc) + (y2 - y1) * (y1 - yc)),\n        c = xc * xc + yc * yc + x1 * x1 + y1 * y1 - 2 * (xc * x1 + yc * y1) - r * r,\n        d = b * b - 4 * a * c,\n        u1 = 0,\n        u2 = 0,\n        x = 0,\n        y = 0;\n\n    if (a === 0) {\n      return [0, [0, 0]];\n    } else if (d < 0) {\n      return [0, [0, 0]];\n    }\n\n    u1 = (-b + sqrt(d)) / (2 * a);\n    u2 = (-b - sqrt(d)) / (2 * a);\n\n    if (0 <= u1 && u1 <= 1) {\n      x = x1 + u1 * (x2 - x1);\n      y = y1 + u1 * (y2 - y1);\n      return [1, [x, y]];\n    } else if (0 <= u2 && u2 <= 1) {\n      x = x1 + u2 * (x2 - x1);\n      y = y1 + u2 * (y2 - y1);\n      return [1, [x, y]];\n    } else {\n      return [0, [0, 0]];\n    }\n  } // counterclockwise rotate 2D vector, xy, by angle (in degrees)\n  // [original CKOG uses clockwise rotation]\n\n\n  function rotate(xy, angle) {\n    var xynew = [0, 0];\n\n    if (angle === -60) {\n      xynew[0] = xy[0] * CK.cos60 + xy[1] * CK.sin60;\n      xynew[1] = -xy[0] * CK.sin60 + xy[1] * CK.cos60;\n    } else if (angle === -120) {\n      xynew[0] = -xy[0] * CK.cos60 + xy[1] * CK.sin60;\n      xynew[1] = -xy[0] * CK.sin60 - xy[1] * CK.cos60;\n    } else {\n      // !!!!! This should not happen for this projection!!!!\n      // the general algorith: cos(angle) * xy + sin(angle) * perpendicular(xy)\n      // return cos(angle * radians) * xy + sin(angle * radians) * perpendicular(xy);\n      //console.log(\"rotate: angle \" + angle + \" different than -60 or -120!\");\n      // counterclockwise\n      xynew[0] = xy[0] * cos(angle * radians) - xy[1] * sin(angle * radians);\n      xynew[1] = xy[0] * sin(angle * radians) + xy[1] * cos(angle * radians);\n    }\n\n    return xynew;\n  } // truncate towards zero like int() in Perl\n\n\n  function truncate(n) {\n    return Math[n > 0 ? \"floor\" : \"ceil\"](n);\n  }\n\n  function equator(m) {\n    var l = CK.deltaMEq * m,\n        jointE = [0, 0];\n\n    if (l <= CK.lengthGF) {\n      jointE = [CK.pointG[0], l];\n    } else {\n      l = l - CK.lengthGF;\n      jointE = interpolate(l, CK.lengthAB, CK.pointF, CK.pointE);\n    }\n\n    return jointE;\n  }\n\n  function jointE(m) {\n    return equator(m);\n  }\n\n  function jointT(m) {\n    return lineIntersection(CK.pointM, 2 * m / 3, jointE(m), m / 3);\n  }\n\n  function jointF(m) {\n    if (m === 0) {\n      return [CK.pointA + CK.lengthAB, 0];\n    }\n\n    var xy = lineIntersection(CK.pointA, m, CK.pointM, 2 * m / 3);\n    return xy;\n  }\n\n  function lengthTorridSegment(m) {\n    return distance(jointE(m), jointT(m));\n  }\n\n  function lengthMiddleSegment(m) {\n    return distance(jointT(m), jointF(m));\n  }\n\n  function parallel73(m) {\n    var p73 = [0, 0],\n        jF = jointF(m),\n        lF = 0,\n        xy = [0, 0];\n\n    if (m <= 30) {\n      p73[0] = CK.pointA[0] + CK.lengthAP73 * cos(m * radians);\n      p73[1] = CK.pointA[1] + CK.lengthAP73 * sin(m * radians);\n      lF = distance(jF, p73);\n    } else {\n      p73 = lineIntersection(CK.pointT, -60, jF, m);\n      lF = distance(jF, p73);\n\n      if (m > 44) {\n        xy = lineIntersection(CK.pointT, -60, jF, 2 / 3 * m);\n\n        if (xy[0] > p73[0]) {\n          p73 = xy;\n          lF = -distance(jF, p73);\n        }\n      }\n    }\n\n    return {\n      parallel73: p73,\n      lengthParallel73: lF\n    };\n  }\n\n  function parallel75(m) {\n    return [CK.pointA[0] + CK.lengthAP75 * cos(m * radians), CK.pointA[1] + CK.lengthAP75 * sin(m * radians)];\n  } // special functions to transform lon/lat to x/y\n\n\n  function ll2mp(lon, lat) {\n    var south = [0, 6, 7, 8, 5],\n        o = truncate((lon + 180) / 90 + 1),\n        p,\n        // parallel\n    m = (lon + 720) % 90 - 45,\n        // meridian\n    s = sign(m);\n    m = abs(m);\n    if (o === 5) o = 1;\n    if (lat < 0) o = south[o];\n    p = abs(lat);\n    return [m, p, s, o];\n  }\n\n  function zoneA(m, p) {\n    return [CK.pointA[0] + (90 - p) * 104, 0];\n  }\n\n  function zoneB(m, p) {\n    return [CK.pointG[0] - p * 100, 0];\n  }\n\n  function zoneC(m, p) {\n    var l = 104 * (90 - p);\n    return [CK.pointA[0] + l * cos(m * radians), CK.pointA[1] + l * sin(m * radians)];\n  }\n\n  function zoneD(m\n  /*, p */\n  ) {\n    // p = p; // just keep it for symmetry in signature\n    return equator(m);\n  }\n\n  function zoneE(m, p) {\n    var l = 1560 + (75 - p) * 100;\n    return [CK.pointA[0] + l * cos(m * radians), CK.pointA[1] + l * sin(m * radians)];\n  }\n\n  function zoneF(m, p) {\n    return interpolate(p, 15, CK.pointE, CK.pointD);\n  }\n\n  function zoneG(m, p) {\n    var l = p - 15;\n    return interpolate(l, 58, CK.pointD, CK.pointT);\n  }\n\n  function zoneH(m, p) {\n    var p75 = parallel75(45),\n        p73a = parallel73(m),\n        p73 = p73a.parallel73,\n        lF = distance(CK.pointT, CK.pointB),\n        lF75 = distance(CK.pointB, p75),\n        l = (75 - p) * (lF75 + lF) / 2,\n        xy = [0, 0];\n\n    if (l <= lF75) {\n      xy = interpolate(l, lF75, p75, CK.pointB);\n    } else {\n      l = l - lF75;\n      xy = interpolate(l, lF, CK.pointB, p73);\n    }\n\n    return xy;\n  }\n\n  function zoneI(m, p) {\n    var p73a = parallel73(m),\n        lT = lengthTorridSegment(m),\n        lM = lengthMiddleSegment(m),\n        l = p * (lT + lM + p73a.lengthParallel73) / 73,\n        xy;\n\n    if (l <= lT) {\n      xy = interpolate(l, lT, jointE(m), jointT(m));\n    } else if (l <= lT + lM) {\n      l = l - lT;\n      xy = interpolate(l, lM, jointT(m), jointF(m));\n    } else {\n      l = l - lT - lM;\n      xy = interpolate(l, p73a.lengthParallel73, jointF(m), p73a.parallel73);\n    }\n\n    return xy;\n  }\n\n  function zoneJ(m, p) {\n    var p75 = parallel75(m),\n        lF75 = distance(jointF(m), p75),\n        p73a = parallel73(m),\n        p73 = p73a.parallel73,\n        lF = p73a.lengthParallel73,\n        l = (75 - p) * (lF75 - lF) / 2,\n        xy = [0, 0];\n\n    if (l <= lF75) {\n      xy = interpolate(l, lF75, p75, jointF(m));\n    } else {\n      l = l - lF75;\n      xy = interpolate(l, -lF, jointF(m), p73);\n    }\n\n    return xy;\n  }\n\n  function zoneK(m, p, l15) {\n    var l = p * l15 / 15,\n        lT = lengthTorridSegment(m),\n        lM = lengthMiddleSegment(m),\n        xy = [0, 0];\n\n    if (l <= lT) {\n      // point is in torrid segment\n      xy = interpolate(l, lT, jointE(m), jointT(m));\n    } else {\n      // point is in middle segment\n      l = l - lT;\n      xy = interpolate(l, lM, jointT(m), jointF(m));\n    }\n\n    return xy;\n  }\n\n  function zoneL(m, p, l15) {\n    var p73a = parallel73(m),\n        p73 = p73a.parallel73,\n        lT = lengthTorridSegment(m),\n        lM = lengthMiddleSegment(m),\n        xy,\n        lF = p73a.lengthParallel73,\n        l = l15 + (p - 15) * (lT + lM + lF - l15) / 58;\n\n    if (l <= lT) {\n      //on torrid segment\n      xy = interpolate(l, lT, jointE(m), jointF(m));\n    } else if (l <= lT + lM) {\n      //on middle segment\n      l = l - lT;\n      xy = interpolate(l, lM, jointT(m), jointF(m));\n    } else {\n      //on frigid segment\n      l = l - lT - lM;\n      xy = interpolate(l, lF, jointF(m), p73);\n    }\n\n    return xy;\n  } // convert half-octant meridian,parallel to x,y coordinates.\n  // arguments are meridian, parallel\n\n\n  function mp2xy(m, p) {\n    var xy = [0, 0],\n        lT,\n        p15a,\n        p15,\n        flag15,\n        l15;\n\n    if (m === 0) {\n      // zones (a) and (b)\n      if (p >= 75) {\n        xy = zoneA(m, p);\n      } else {\n        xy = zoneB(m, p);\n      }\n    } else if (p >= 75) {\n      xy = zoneC(m, p);\n    } else if (p === 0) {\n      xy = zoneD(m, p);\n    } else if (p >= 73 && m <= 30) {\n      xy = zoneE(m, p);\n    } else if (m === 45) {\n      if (p <= 15) {\n        xy = zoneF(m, p);\n      } else if (p <= 73) {\n        xy = zoneG(m, p);\n      } else {\n        xy = zoneH(m, p);\n      }\n    } else {\n      if (m <= 29) {\n        xy = zoneI(m, p);\n      } else {\n        // supple zones (j), (k) and (l)\n        if (p >= 73) {\n          xy = zoneJ(m, p);\n        } else {\n          //zones (k) and (l)\n          p15a = circleLineIntersection(CK.pointC, CK.radius, jointT(m), jointF(m));\n          flag15 = p15a[0];\n          p15 = p15a[1];\n          lT = lengthTorridSegment(m);\n\n          if (flag15 === 1) {\n            // intersection is in middle segment\n            l15 = lT + distance(jointT(m), p15);\n          } else {\n            // intersection is in torrid segment\n            p15a = circleLineIntersection(CK.pointC, CK.radius, jointE(m), jointT(m));\n            flag15 = p15a[0];\n            p15 = p15a[1];\n\n            if (flag15 === 0) {//console.log(\"Something weird!\");\n              // TODO: Trap this! Something odd happened!\n            }\n\n            l15 = lT - distance(jointT(m), p15);\n          }\n\n          if (p <= 15) {\n            xy = zoneK(m, p, l15);\n          } else {\n            //zone (l)\n            xy = zoneL(m, p, l15);\n          }\n        }\n      }\n    }\n\n    return xy;\n  } // from half-octant to megamap (single rotated octant)\n\n\n  function mj2g(xy, octant) {\n    var xynew = [0, 0];\n\n    if (octant === 0) {\n      xynew = rotate(xy, -60);\n    } else if (octant === 1) {\n      xynew = rotate(xy, -120);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 2) {\n      xynew = rotate(xy, -60);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 3) {\n      xynew = rotate(xy, -120);\n      xynew[0] += CK.lengthMG;\n    } else if (octant === 4) {\n      xynew = rotate(xy, -60);\n      xynew[0] += CK.lengthMG;\n    } else if (octant === 5) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -60);\n      xynew[0] += CK.lengthMG;\n    } else if (octant === 6) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -120);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 7) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -60);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 8) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -120);\n      xynew[0] += CK.lengthMG;\n    } else {\n      // TODO trap this some way.\n      // ERROR!\n      // print \"Error converting to M-map coordinates; there is no Octant octant!\\n\";\n      //console.log(\"mj2g: something weird happened!\");\n      return xynew;\n    }\n\n    return xynew;\n  } // general CK map projection\n\n\n  function forward(lambda, phi) {\n    // lambda, phi are in radians.\n    var lon = lambda * degrees,\n        lat = phi * degrees,\n        res = ll2mp(lon, lat),\n        m = res[0],\n        // 0 ≤ m ≤ 45\n    p = res[1],\n        // 0 ≤ p ≤ 90\n    s = res[2],\n        // -1 / 1 = side of m\n    o = res[3],\n        // octant\n    xy = mp2xy(m, p),\n        mm = mj2g([xy[0], s * xy[1]], o);\n    return mm;\n  }\n\n  return forward;\n}\n\nfunction cahillKeyesProjection() {\n  var mg = 10000,\n      m = projectionMutator(cahillKeyesRaw);\n  return m(mg);\n}","map":null,"metadata":{},"sourceType":"module"}
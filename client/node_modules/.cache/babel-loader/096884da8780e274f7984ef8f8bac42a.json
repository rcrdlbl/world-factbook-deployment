{"ast":null,"code":"/*\n * Imago projection, by Justin Kunimune\n *\n * Inspired by Hajime Narukawaâ€™s AuthaGraph\n *\n */\nimport { abs, acos, asin, atan, atan2, cos, degrees, epsilon, floor, halfPi, pi, pow, sign, sin, sqrt, tan } from \"./math\";\nimport { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { default as clipPolygon } from \"./clip/polygon\";\nimport { solve } from \"./newton.js\";\nvar hypot = Math.hypot;\nvar ASIN_ONE_THD = asin(1 / 3),\n    centrums = [[halfPi, 0, 0, -halfPi, 0, sqrt(3)], [-ASIN_ONE_THD, 0, pi, halfPi, 0, -sqrt(3)], [-ASIN_ONE_THD, 2 * pi / 3, pi, 5 * pi / 6, 3, 0], [-ASIN_ONE_THD, -2 * pi / 3, pi, pi / 6, -3, 0]],\n    TETRAHEDRON_WIDE_VERTEX = {\n  sphereSym: 3,\n  planarSym: 6,\n  width: 6,\n  height: 2 * sqrt(3),\n  centrums: centrums,\n  rotateOOB: function rotateOOB(x, y, xCen, yCen) {\n    yCen * 0;\n    if (abs(x) > this.width / 2) return [2 * xCen - x, -y];else return [-x, this.height * sign(y) - y];\n  },\n  inBounds: function inBounds() {\n    return true;\n  }\n},\n    configuration = TETRAHEDRON_WIDE_VERTEX;\nexport function imagoRaw(k) {\n  function faceProject(lon, lat) {\n    var tht = atan((lon - asin(sin(lon) / sqrt(3))) / pi * sqrt(12)),\n        p = (halfPi - lat) / atan(sqrt(2) / cos(lon));\n    return [pow(p, k) * sqrt(3) / cos(tht), tht];\n  }\n\n  function faceInverse(r, th) {\n    var l = solve(function (l) {\n      return atan((l - asin(sin(l) / sqrt(3))) / pi * sqrt(12));\n    }, th, th / 2),\n        R = r / (sqrt(3) / cos(th));\n    return [halfPi - pow(R, 1 / k) * atan(sqrt(2) / cos(l)), l];\n  }\n\n  function obliquifySphc(latF, lonF, pole) {\n    if (pole == null) // null pole indicates that this procedure should be bypassed\n      return [latF, lonF];\n    var lat0 = pole[0],\n        lon0 = pole[1],\n        tht0 = pole[2];\n    var lat1, lon1;\n    if (lat0 == halfPi) lat1 = latF;else lat1 = asin(sin(lat0) * sin(latF) + cos(lat0) * cos(latF) * cos(lon0 - lonF)); // relative latitude\n\n    if (lat0 == halfPi) // accounts for all the 0/0 errors at the poles\n      lon1 = lonF - lon0;else if (lat0 == -halfPi) lon1 = lon0 - lonF - pi;else {\n      lon1 = acos((cos(lat0) * sin(latF) - sin(lat0) * cos(latF) * cos(lon0 - lonF)) / cos(lat1)) - pi; // relative longitude\n\n      if (isNaN(lon1)) {\n        if (cos(lon0 - lonF) >= 0 && latF < lat0 || cos(lon0 - lonF) < 0 && latF < -lat0) lon1 = 0;else lon1 = -pi;\n      } else if (sin(lonF - lon0) > 0) // it's a plus-or-minus arccos.\n        lon1 = -lon1;\n    }\n    lon1 = lon1 - tht0;\n    return [lat1, lon1];\n  }\n\n  function obliquifyPlnr(coords, pole) {\n    if (pole == null) //this indicates that you just shouldn't do this calculation\n      return coords;\n    var lat1 = coords[0],\n        lon1 = coords[1];\n    var lat0 = pole[0],\n        lon0 = pole[1],\n        tht0 = pole[2];\n    lon1 += tht0;\n    var latf = asin(sin(lat0) * sin(lat1) - cos(lat0) * cos(lon1) * cos(lat1)),\n        lonf,\n        innerFunc = sin(lat1) / cos(lat0) / cos(latf) - tan(lat0) * tan(latf);\n    if (lat0 == halfPi) // accounts for special case when lat0 = pi/2\n      lonf = lon1 + lon0;else if (lat0 == -halfPi) // accounts for special case when lat0 = -pi/2\n      lonf = -lon1 + lon0 + pi;else if (abs(innerFunc) > 1) {\n      // accounts for special case when cos(lat1) -> 0\n      if (lon1 == 0 && lat1 < -lat0 || lon1 != 0 && lat1 < lat0) lonf = lon0 + pi;else lonf = lon0;\n    } else if (sin(lon1) > 0) lonf = lon0 + acos(innerFunc);else lonf = lon0 - acos(innerFunc);\n    var thtf = pole[2];\n    return [latf, lonf, thtf];\n  }\n\n  function forward(lon, lat) {\n    var width = configuration.width,\n        height = configuration.height;\n    var numSym = configuration.sphereSym; //we're about to be using this variable a lot\n\n    var latR = -Infinity;\n    var lonR = -Infinity;\n    var centrum = null;\n\n    for (var _i = 0; _i < centrums.length; _i++) {\n      var testCentrum = centrums[_i];\n      //iterate through the centrums to see which goes here\n      var relCoords = obliquifySphc(lat, lon, testCentrum);\n\n      if (relCoords[0] > latR) {\n        latR = relCoords[0];\n        lonR = relCoords[1];\n        centrum = testCentrum;\n      }\n    }\n\n    var lonR0 = floor((lonR + pi / numSym) / (2 * pi / numSym)) * (2 * pi / numSym);\n    var rth = faceProject(lonR - lonR0, latR);\n    var r = rth[0];\n    var th = rth[1] + centrum[3] + lonR0 * numSym / configuration.planarSym;\n    var x0 = centrum[4];\n    var y0 = centrum[5];\n    var output = [r * cos(th) + x0, r * sin(th) + y0];\n\n    if (abs(output[0]) > width / 2 || abs(output[1]) > height / 2) {\n      output = configuration.rotateOOB(output[0], output[1], x0, y0);\n    }\n\n    return output;\n  }\n\n  function invert(x, y) {\n    if (isNaN(x) || isNaN(y)) return null;\n    if (!configuration.inBounds(x, y)) return null;\n    var numSym = configuration.planarSym;\n    var rM = +Infinity;\n    var centrum = null; //iterate to see which centrum we get\n\n    for (var _i2 = 0; _i2 < centrums.length; _i2++) {\n      var testCentrum = centrums[_i2];\n      var rR = hypot(x - testCentrum[4], y - testCentrum[5]);\n\n      if (rR < rM) {\n        //pick the centrum that minimises r\n        rM = rR;\n        centrum = testCentrum;\n      }\n    }\n\n    var th0 = centrum[3],\n        x0 = centrum[4],\n        y0 = centrum[5],\n        r = hypot(x - x0, y - y0),\n        th = atan2(y - y0, x - x0) - th0,\n        thBase = floor((th + pi / numSym) / (2 * pi / numSym)) * (2 * pi / numSym);\n    var relCoords = faceInverse(r, th - thBase);\n    if (relCoords == null) return null;\n    relCoords[1] = thBase * numSym / configuration.sphereSym + relCoords[1];\n    var absCoords = obliquifyPlnr(relCoords, centrum);\n    return [absCoords[1], absCoords[0]];\n  }\n\n  forward.invert = invert;\n  return forward;\n}\nexport function imagoBlock() {\n  var k = 0.68,\n      m = projectionMutator(imagoRaw),\n      p = m(k);\n\n  p.k = function (_) {\n    return arguments.length ? m(k = +_) : k;\n  };\n\n  var a = -atan(1 / sqrt(2)) * degrees,\n      border = [[-180 + epsilon, a + epsilon], [0, 90], [180 - epsilon, a + epsilon], [180 - epsilon, a - epsilon], [-180 + epsilon, a - epsilon], [-180 + epsilon, a + epsilon]];\n  return p.preclip(clipPolygon({\n    type: \"Polygon\",\n    coordinates: [border]\n  })).scale(144.04).rotate([18, -12.5, 3.5]).center([0, 35.2644]);\n}\n\nfunction imagoWideRaw(k, shift) {\n  var imago = imagoRaw(k);\n  var height = configuration.height;\n\n  function forward(lon, lat) {\n    var p = imago(lon, lat),\n        q = [p[1], -p[0]];\n\n    if (q[1] > 0) {\n      q[0] = height - q[0];\n      q[1] *= -1;\n    }\n\n    q[0] += shift;\n    if (q[0] < 0) q[0] += height * 2;\n    return q;\n  }\n\n  function invert(x, y) {\n    x = (x - shift) / height;\n\n    if (x > 1.5) {\n      x -= 2;\n    }\n\n    if (x > 0.5) {\n      x = 1 - x;\n      y *= -1;\n    }\n\n    return imago.invert(-y, x * height);\n  }\n\n  forward.invert = invert;\n  return forward;\n}\n\nexport default function () {\n  var k = 0.59,\n      shift = 1.16,\n      m = projectionMutator(imagoWideRaw),\n      p = m(k, shift);\n\n  p.shift = function (_) {\n    return arguments.length ? clipped(m(k, shift = +_)) : shift;\n  };\n\n  p.k = function (_) {\n    return arguments.length ? clipped(m(k = +_, shift)) : k;\n  };\n\n  function clipped(p) {\n    var N = 100 + 2 * epsilon,\n        border = [],\n        e = 3e-3;\n    var scale = p.scale(),\n        center = p.center(),\n        translate = p.translate(),\n        rotate = p.rotate();\n    p.scale(1).center([0, 90]).rotate([0, 0]).translate([shift, 0]);\n\n    for (var i = N - epsilon; i > 0; i--) {\n      border.unshift(p.invert([1.5 * configuration.height - e, configuration.width / 2 * i / N]));\n      border.push(p.invert([-0.5 * configuration.height + e, configuration.width / 2 * i / N]));\n    }\n\n    border.push(border[0]);\n    return p.scale(scale).center(center).translate(translate).rotate(rotate).preclip(clipPolygon({\n      type: \"Polygon\",\n      coordinates: [border]\n    }));\n  }\n\n  return clipped(p).rotate([18, -12.5, 3.5]).scale(138.42).translate([480, 250]).center([-139.405, 40.5844]);\n}","map":null,"metadata":{},"sourceType":"module"}